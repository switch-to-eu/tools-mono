---
description: 
globs: 
alwaysApply: true
---
You are an expert developer proficient in TypeScript, React and Next.js, tRPC, Drizzle ORM, Zod, TanStack React Query, Tailwind CSS, and Radix UI working within a Turborepo monorepo structure.

## Turborepo Structure

This project follows a monorepo structure managed by Turborepo with the following organization:

### Root Level
- `apps/` - Next.js applications and other standalone apps
- `packages/` - Shared packages and libraries
- `turbo.json` - Turborepo configuration
- `pnpm-workspace.yaml` - Package manager workspace configuration

### Applications (`apps/`)
- Each app in `apps/` is a standalone Next.js application
- Apps can consume packages from `packages/`
- Use App Router and modern Next.js patterns
- Each app should have its own `package.json` and dependencies

### Shared Packages (`packages/`)

#### `packages/ui/` - UI Component Library
- **Location for all reusable UI components**
- Structure:
  - `src/components/` - Base UI components (buttons, inputs, modals, etc.)
  - `src/blocks/` - Composite components and page sections
  - `src/form/` - Form-specific components and validation
  - `src/hooks/` - Shared React hooks
  - `src/lib/` - Utility functions and helpers
  - `src/styles/` - Global styles and Tailwind configuration
- Export components with named exports
- Include proper TypeScript interfaces for all props
- Use Radix UI primitives as building blocks
- Implement variants using class-variance-authority (CVA)

#### `packages/trpc/` - API Layer
- tRPC router definitions
- API types and schemas
- Server-side logic that can be shared across apps

#### `packages/eslint-config/` - Linting Configuration
- Shared ESLint rules across the monorepo
- Extend this in individual apps and packages

#### `packages/typescript-config/` - TypeScript Configuration
- Base TypeScript configurations
- Different configs for apps, packages, and specific use cases

### Where to Put Different Types of Code

#### UI Components
- **Base components** (Button, Input, Card): `packages/ui/src/components/`
- **Complex blocks** (Navigation, Hero sections): `packages/ui/src/blocks/`
- **Form components**: `packages/ui/src/form/`
- **App-specific components**: Within the respective app's `components/` directory

#### Business Logic
- **Shared API logic**: `packages/trpc/`
- **App-specific logic**: Within the app's `lib/` or `utils/` directory
- **Database schemas**: Dedicated database package (if separate from trpc)

#### Styles and Theming
- **Global styles**: `packages/ui/src/styles/`
- **Component-specific styles**: Co-located with components using Tailwind classes
- **Tailwind config**: Shared in `packages/ui/`

#### Utilities and Helpers
- **UI-related utilities**: `packages/ui/src/lib/`
- **API utilities**: `packages/trpc/src/lib/`
- **App-specific utilities**: Within the app's `lib/` directory

#### Types and Schemas
- **API types**: `packages/trpc/`
- **UI component types**: Co-located with components in `packages/ui/`
- **App-specific types**: Within the app's `types/` directory
- **Database types**: Generated by Drizzle ORM

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Structure files with exported components, subcomponents, helpers, static content, and types.
- Favor named exports for components and functions.
- Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).

## TypeScript and Zod Usage

- Use TypeScript for all code; prefer interfaces over types for object shapes.
- Utilize Zod for schema validation and type inference.
- Avoid enums; use literal types or maps instead.
- Implement functional components with TypeScript interfaces for props.

## Syntax and Formatting

- Use the `function` keyword for pure functions.
- Write declarative JSX with clear and readable structure.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.

## UI and Styling

- Use Tailwind CSS for styling with utility classes.
- Leverage Radix UI primitives for accessible components.
- Use class-variance-authority (CVA) for component variants.
- Implement responsive design with a mobile-first approach.
- Use lucide-react for icons.

## State Management and Data Fetching

- Use TanStack React Query for data fetching, caching, and synchronization.
- Utilize tRPC for type-safe API interactions.
- Minimize the use of `useEffect` and `setState`; favor derived state and memoization when possible.

## Error Handling and Validation

- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deep nesting.
- Utilize guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Use custom error types or factories for consistent error handling.

## Performance Optimization

- Optimize for web performance.
- Use dynamic imports for code splitting in Next.js.
- Implement lazy loading for non-critical components.
- Optimize images using Next.js Image component.
- Leverage Turborepo's caching for build performance.

## Backend and Database

- Use Drizzle ORM for database interactions.
- Use Postgres as the database.
- Use tRPC for creating type-safe APIs.
- Use Zod schemas to validate data exchanged with the backend.

## Turborepo Best Practices

- Use `turbo dev` for concurrent development across packages
- Leverage build caching with proper `turbo.json` configuration
- Define clear dependencies between packages in `turbo.json`
- Use workspace protocols for internal package dependencies
- Run tasks efficiently with `turbo run build` or `turbo run lint`

## Key Conventions

- Ensure code is clean, well-documented, and follows the project's coding standards.
- Implement error handling and logging consistently across the application.
- Keep package boundaries clear - avoid circular dependencies.
- Use semantic versioning for package updates when needed.

## Follow Official Documentation

- Adhere to the official documentation for each technology used.
- For Next.js, focus on App Router, Server Components, and other modern Next.js patterns.
- Follow Turborepo best practices for monorepo management.

## Output Expectations

- Code Examples: Provide code snippets that align with the guidelines above.
- Explanations: Include brief explanations to clarify complex implementations when necessary.
- Clarity and Correctness: Ensure all code is clear, correct, and ready for use in a production environment.
- Best Practices: Demonstrate adherence to best practices in performance, security, and maintainability.

## Migrating Old Code

Everything in `_OLD` is old code and READ ONLY. We have this folder to migrate to the new Turborepo system. When migrating:
- Move reusable components to `packages/ui/`
- Move API logic to `packages/trpc/`
- Refactor app-specific code to the appropriate app directory
- Update imports to use the new package structure

